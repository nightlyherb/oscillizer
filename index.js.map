{
  "version": 3,
  "sources": ["../src/MVC/Models/AppState.ts", "../src/MVC/Controllers/PassingController/EventTargetPassingController.ts", "../src/Engine/RLE/PatternParser.ts", "../src/BaseTypes/Rule/INTRule.ts", "../src/BaseTypes/Rule/TotalisticRule.ts", "../src/Engine/RLE/RuleParser.ts", "../src/MVC/Controllers/OscStatsController/RLEHelpers.ts", "../src/BaseTypes/BoundingBox.ts", "../src/BaseTypes/CellMap.ts", "../src/MVC/Controllers/OscStatsController/OscHelpers.ts", "../src/Engine/Board/SimpleBoard/AbcSimpleBoard.ts", "../src/Engine/Board/SimpleBoard/SimpleTotalisticBoard.ts", "../src/BaseTypes/Neighbors/INTNeighbors.ts", "../src/Engine/Board/SimpleBoard/SimpleINTBoard.ts", "../src/AppConfig.ts", "../src/MVC/Controllers/OscStatsController/OscStatsController.ts", "../src/MVC/Views/OscillizerCanvasView/CanvasHelpers.ts", "../src/MVC/Views/OscillizerCanvasView/OscillizerCanvasView.ts", "../src/MVC/Views/OscStatsView/OscStatsView.ts", "../src/index.ts"],
  "sourcesContent": ["/**\n * A class that represents a single group of state.\n * @class\n */\nclass AppState {\n  /**\n   * @param {*} value - The initial value of this state\n   * @param {EventTarget} [eventTarget] - The EventTarget to use for firing state changes\n   */\n  constructor(value, eventTarget) {\n    /** @type {EventTarget} */\n    this.eventTarget = eventTarget || new EventTarget();\n    /** @type {*} */\n    this.value = value;\n  }\n\n  /**\n   * Set the value and fire `change` event.\n   * @param {*} newValue - The new value\n   */\n  setValue(newValue) {\n    this.value = newValue;\n    this.eventTarget.dispatchEvent(\n      new CustomEvent('change', { detail: { source: this } })\n    );\n  }\n}\n\nexport default AppState;\n", "/**\n * @typedef {import(\"../IController\").IController} IController\n * @typedef {import(\"../../Models/AppState\").default} AppState\n */\n\n/**\n * A controller that just passes the value of `event.target`.\n * `sourceElement` is not needed as we are using `event.target` anyway.\n * @class\n * @implements {IController}\n */\nclass EventTargetPassingController {\n  /**\n   * @param {AppState} targetState\n   */\n  constructor(targetState) {\n    /** @type {AppState} */\n    this.targetState = targetState;\n    /**\n     * The update callback.\n     * @type {function(Event): void}\n     */\n    this.update = (event) => {\n      if (!event.target) {\n        return;\n      }\n      // @ts-ignore\n      this.targetState.setValue(event.target.value);\n    };\n  }\n}\n\nexport default EventTargetPassingController;\n", "/**\n * The intermediate state during RLE parsing.\n * @class\n */\nclass PatternParser {\n  /**\n   * Initialize the parser with the given state.\n   *\n   * @param {Object} initialState - The initial state to override with\n   * @property {boolean|undefined} initialState.isFinished\n   * @property {Array<Cell>|undefined} initialState.cells\n   * @property {Array<number>|undefined} initialState.runCount\n   * @property {Cell|undefined} initialState.currentCell\n   *\n   */\n  constructor(initialState = {}) {\n    /** @type {boolean} */\n    this.isFinished = initialState.isFinished || false;\n    /** @type {Array<Cell>} */\n    this.cells = initialState.cells || [];\n    /** @type {number} */\n    this.runCount = initialState.runCount || 0;\n    /** @type {Cell} */\n    this.currentCell = initialState.currentCell || [0, 0];\n  }\n\n  finishParsing() {\n    this.isFinished = true;\n  }\n\n  addNewlines() {\n    const [/* x */, y] = this.currentCell;\n    const runCount = this.runCount || 1;\n    this.currentCell = [0, y + runCount];\n    this.runCount = 0;\n  }\n\n  /**\n   * Append `digit` to `this.runCount`\n   * @param {number} digit - The digit to append\n   */\n  updateRunCount(digit) {\n    this.runCount = this.runCount * 10 + digit;\n  }\n\n  /**\n   * @param {number} cellState\n   */\n  drawRun(cellState) {\n    const [x, y] = this.currentCell;\n    const runCount = this.runCount || 1;\n    const newCells = new Array(runCount).fill(0).map((v, i) => [x + i, y]);\n\n    // Refactor addNewCells into a dependency if needs variation in behavior\n    const addNewCells = (nc, s) => {\n      if (s) { this.cells = this.cells.concat(nc); }\n    };\n    addNewCells(newCells, cellState);\n\n    this.currentCell = [x + runCount, y];\n    this.runCount = 0;\n  }\n}\n\nexport default PatternParser;\n", "/**\n * @typedef {import('../Neighbors/INTNeighbors').INTNeighbor} INTNeighbor\n */\n\n/**\n * An Isotropic non-totalistic rule with the given birth and survival conditions.\n */\nclass INTRule {\n  /**\n   * @param {Array<INTNeighbor>} births - The birth conditions\n   * @param {Array<INTNeighbor>} survivals - The survival conditions\n   */\n  constructor(births, survivals) {\n    /** @type {Array<INTNeighbor>} */ this.births = births;\n    /** @type {Array<INTNeighbor>} */ this.survivals = survivals;\n  }\n}\nexport default INTRule;\n", "/**\n * A Totalistic Rule subclass with the given birth and survival conditions.\n */\nclass TotalisticRule {\n  /**\n   * @param {Array<number>} births\n   * @param {Array<number>} survivals\n   */\n  constructor(births, survivals) {\n    /** @type {Array<number>} */ this.births = births;\n    /** @type {Array<number>} */ this.survivals = survivals;\n  }\n}\nexport default TotalisticRule;\n", "import INTRule from '../../BaseTypes/Rule/INTRule.js';\nimport TotalisticRule from '../../BaseTypes/Rule/TotalisticRule.js';\n\n/**\n * Try to parse totalistic rule from rulestring.\n * @param {string} ruleString\n * @returns {TotalisticRule|undefined} - A totalistic rule on success, `undefined` on fail.\n */\nexport const parseTotalisticRule = (ruleString) => {\n  /**\n   * @private\n   * @typedef {{\n   *  success: boolean,\n   *  births: Array<number>,\n   *  survivals: Array<number>,\n   *  isBirth: boolean,\n   * }} State\n   */\n\n  /**\n   * @param {State} state\n   * @param {string} char\n   * @property {1} char.length\n   * @returns {State} The updated state\n   */\n  const updateState = (state, char) => {\n    if (!state.success) {\n      return state;\n    }\n\n    const {\n      success, births, survivals, isBirth,\n    } = state;\n\n    switch (char) {\n      case '0': case '1': case '2': case '3': case '4':\n      case '5': case '6': case '7': case '8':\n        (isBirth ? births : survivals).push(parseInt(char, 10));\n        return {\n          success, births, survivals, isBirth,\n        };\n      case 'b': case 'B':\n        return {\n          success, births, survivals, isBirth: true,\n        };\n      case 's': case 'S':\n        return {\n          success, births, survivals, isBirth: false,\n        };\n      case '/':\n        return {\n          success, births, survivals, isBirth: !isBirth,\n        };\n      default:\n        return {\n          success: false, births: [], survivals: [], isBirth: false,\n        };\n    }\n  };\n  const finalState = Array.from(ruleString).reduce(\n    updateState,\n    {\n      success: true, births: [], survivals: [], isBirth: false,\n    }\n  );\n  if (!finalState.success) {\n    return undefined;\n  }\n  const births = [...new Set(finalState.births).keys()];\n  const survivals = [...new Set(finalState.survivals).keys()];\n  return new TotalisticRule(births, survivals);\n};\n\n/**\n * Try to parse an INT rule from rulestring.\n * @param {string} ruleString\n * @returns {INTRule|undefined} - An INT rule on success, `undefined` on fail.\n */\nexport const parseINTRule = (ruleString) => {\n  /**\n   * @typedef {import('../../BaseTypes/Neighbors/INTNeighbors.js').INTNeighbor} INTNeighbor\n   */\n\n  /**\n   * @private\n   * @typedef {{\n   *  isBirth: boolean,\n   *  births: Set<INTNeighbor>,\n   *  survivals: Set<INTNeighbor>,\n   * }} State\n   */\n\n  // Dependent function and objects\n\n  /** @type {function(State): State} */\n  const copyWithBirth = (state) => ({\n    isBirth: true,\n    births: state.births,\n    survivals: state.survivals,\n  });\n\n  /** @type {function(State): State} */\n  const copyWithSurvival = (state) => ({\n    isBirth: false,\n    births: state.births,\n    survivals: state.survivals,\n  });\n\n  /** @type {function(State): State} */\n  const copyWithToggledBirth = (state) => ({\n    isBirth: !state.isBirth,\n    births: state.births,\n    survivals: state.survivals,\n  });\n\n  // Assumes word matches `/[0-8][-cekainyqjrtwz]/`\n  /** @type {Array<Array<INTNeighbor>>} */\n  const allNeighborsByCount = [\n    [\n      '0',\n    ],\n    [\n      '1c', '1e',\n    ],\n    [\n      '2c', '2e',\n      '2a', '2k', '2i', '2n',\n    ],\n    [\n      '3c', '3e',\n      '3a', '3k', '3i', '3n',\n      '3j', '3q', '3r', '3y',\n    ],\n    [\n      '4c', '4e',\n      '4a', '4k', '4i', '4n',\n      '4j', '4q', '4r', '4y',\n      '4t', '4w', '4z',\n    ],\n    [\n      '5c', '5e',\n      '5a', '5k', '5i', '5n',\n      '5j', '5q', '5r', '5y',\n    ],\n    [\n      '6c', '6e',\n      '6a', '6k', '6i', '6n',\n    ],\n    [\n      '7c', '7e',\n    ],\n    [\n      '8',\n    ],\n  ];\n\n  /** @type {Array<(Map<string, INTNeighbor>)>} */\n  const neighborsByCountAndChar = [\n    new Map(),\n    new Map([\n      ['c', '1c'],\n      ['e', '1e'],\n    ]),\n    new Map([\n      ['c', '2c'],\n      ['e', '2e'],\n      ['a', '2a'],\n      ['k', '2k'],\n      ['i', '2i'],\n      ['n', '2n'],\n    ]),\n    new Map([\n      ['c', '3c'],\n      ['e', '3e'],\n      ['a', '3a'],\n      ['k', '3k'],\n      ['i', '3i'],\n      ['n', '3n'],\n      ['j', '3j'],\n      ['q', '3q'],\n      ['r', '3r'],\n      ['y', '3y'],\n    ]),\n    new Map([\n      ['c', '4c'],\n      ['e', '4e'],\n      ['a', '4a'],\n      ['k', '4k'],\n      ['i', '4i'],\n      ['n', '4n'],\n      ['j', '4j'],\n      ['q', '4q'],\n      ['r', '4r'],\n      ['y', '4y'],\n      ['w', '4w'],\n      ['t', '4t'],\n      ['z', '4z'],\n    ]),\n    new Map([\n      ['c', '5c'],\n      ['e', '5e'],\n      ['a', '5a'],\n      ['k', '5k'],\n      ['i', '5i'],\n      ['n', '5n'],\n      ['j', '5j'],\n      ['q', '5q'],\n      ['r', '5r'],\n      ['y', '5y'],\n    ]),\n    new Map([\n      ['c', '6c'],\n      ['e', '6e'],\n      ['a', '6a'],\n      ['k', '6k'],\n      ['i', '6i'],\n      ['n', '6n'],\n    ]),\n    new Map([\n      ['c', '7c'],\n      ['e', '7e'],\n    ]),\n    new Map(),\n  ];\n\n  /** @type {function(string): Set<INTNeighbor>} */\n  const getNeighborsFromWord = (word) => {\n    const neighborSet = new Set();\n    const count = parseInt(word[0], 10);\n    // The chars before the first `-` are births\n    // The chars after them are survivals\n    const [birthsString, ...survivalsStrings] = word.slice(1).split('-');\n    if (birthsString === '') {\n      allNeighborsByCount[count].forEach((n) => neighborSet.add(n));\n    } else {\n      Array.from(birthsString).forEach(\n        (c) => neighborSet.add(neighborsByCountAndChar[count].get(c))\n      );\n    }\n    Array.from(survivalsStrings.join('')).forEach(\n      (c) => neighborSet.delete(neighborsByCountAndChar[count].get(c))\n    );\n    return neighborSet;\n  };\n\n  // Main logic\n  /** @type {State} */\n  const initialState = {\n    isBirth: false, births: new Set(), survivals: new Set(),\n  };\n\n  const words = ruleString.match(/[bBsS/]|[0-8][-cekainyqjrtwz]*/g);\n  if (words.reduce((psum, w) => psum + w.length, 0) !== ruleString.length) {\n    return undefined;\n  }\n  const finalState = words.reduce(\n    (state, word) => {\n      if (word === 'b' || word === 'B') {\n        return copyWithBirth(state);\n      }\n      if (word === 's' || word === 'S') {\n        return copyWithSurvival(state);\n      }\n      if (word === '/') {\n        return copyWithToggledBirth(state);\n      }\n      // Neighbors\n      const neighborsSet = getNeighborsFromWord(word);\n      const targetSet = (state.isBirth ? state.births : state.survivals);\n      neighborsSet.forEach((n) => targetSet.add(n));\n      return state;\n    },\n    initialState\n  );\n  return new INTRule([...finalState.births], [...finalState.survivals]);\n};\n", "import PatternParser from '../../../Engine/RLE/PatternParser.js';\nimport { parseINTRule, parseTotalisticRule } from '../../../Engine/RLE/RuleParser.js';\n\n/** @module */\n\nconst mapStateFromChar = new Map(\n  [\n    ['.', 0], ['A', 1], ['B', 0], ['C', 1], ['D', 0], ['E', 1], ['F', 0],\n    ['b', 0], ['o', 1],\n  ]\n);\n\n/**\n * @private\n * @param {PatternParser} parserState\n * @param {string} c\n * @returns {PatternParser}\n */\nconst updateParserState = (parserState, c) => {\n  // Passthrough if the parser is finished.\n  if (parserState.isFinished) {\n    return parserState;\n  }\n\n  if (c === '!') {\n    parserState.finishParsing();\n    return parserState;\n  }\n\n  // Update the run count if it is a digit\n  if (c >= '0' && c <= '9') {\n    const d = c.charCodeAt(0) - '0'.charCodeAt(0);\n    parserState.updateRunCount(d);\n    return parserState;\n  }\n\n  // Jump to next line if it is '$'\n  if (c === '$') {\n    parserState.addNewlines();\n    return parserState;\n  }\n\n  // Draw the run if it is a character\n  const currState = mapStateFromChar.get(c) || 0;\n  parserState.drawRun(currState);\n  return parserState;\n};\n\n// Convert RLE without headers into a pattern of form [[x, y]]\nexport const parseBody = (rleBodyString) => {\n  const parseResult = (\n    [...rleBodyString].reduce(updateParserState, new PatternParser())\n  );\n  parseResult.finishParsing(); // No-op for now but semantically needed\n  return parseResult.cells;\n};\n\n/* Body extracting related code */\n\n/**\n * @private\n * @param {string} rleString\n * @returns {{body: string, rule: string|null}} The RLE Body and Rule, both as a string\n */\nconst extractParts = (rleString) => {\n  const lines = (\n    rleString.split('\\n')\n      .map((line) => line.replace(/\\s/g, ''))\n      .filter((line) => line !== '') // We ignore empty lines\n  );\n\n  /** @type {function(string): boolean} */\n  const isNotComment = (line) => !line.startsWith('#');\n  const firstNonCommentIndex = lines.findIndex(isNotComment);\n\n  const headerRegex = /^x=\\d+,y=\\d+,rule=(.*)/;\n  const matchedHeader = headerRegex.exec(lines[firstNonCommentIndex]);\n  const bodyStartIndex = firstNonCommentIndex + (matchedHeader !== null ? 1 : 0);\n  const body = lines.slice(bodyStartIndex).join('');\n  const rule = (matchedHeader) ? matchedHeader[1] : null;\n  return { body, rule };\n};\n\n/**\n * @typedef {import('../../../BaseTypes/Rule/Rule.js').Rule} Rule\n */\n\n/**\n * Given an RLE string, parse and return the rule and pattern.\n * @param {string} rleString - The RLE string.\n * @returns {{pattern: Array<Cell>, rule: Rule}} - The pattern and the rule.\n */\nexport const parse = (rleString) => {\n  const { rule: ruleString, body } = extractParts(rleString);\n  const pattern = parseBody(body);\n  const rule = (\n    parseTotalisticRule(ruleString)\n    || parseINTRule(ruleString)\n    || undefined\n  );\n  return { pattern, rule };\n};\n", "/**\n * A bounding box consists of min/max of the X/Y coordinates.\n * For an empty pattern the bounding box is `(Inf, Inf, -Inf, -Inf)`\n * because it's an identity in the addition below.\n */\nclass BoundingBox {\n  /**\n   * @param {number} xmin\n   * @param {number} xmax\n   * @param {number} ymin\n   * @param {number} ymax\n   */\n  constructor(xmin = Infinity, xmax = -Infinity, ymin = Infinity, ymax = -Infinity) {\n    /** @type {number} */ this.xmin = xmin;\n    /** @type {number} */ this.xmax = xmax;\n    /** @type {number} */ this.ymin = ymin;\n    /** @type {number} */ this.ymax = ymax;\n  }\n\n  /**\n   * Return a new bounding box that is the result of\n   * merging `this` with the `other` bounding box.\n   *\n   * @param {BoundingBox} other - The other box to merge with.\n   * @returns {BoundingBox} - The merged bounding box.\n   */\n  plus(other) {\n    const xmin = Math.min(this.xmin, other.xmin);\n    const xmax = Math.max(this.xmax, other.xmax);\n    const ymin = Math.min(this.ymin, other.ymin);\n    const ymax = Math.max(this.ymax, other.ymax);\n    return new BoundingBox(xmin, xmax, ymin, ymax);\n  }\n\n  /**\n   * Given an array of bounding boxes, merge all of them and return the merged box.\n   *\n   * @param  {Array<BoundingBox>} boxes - The boxes to merge.\n   * @returns {BoundingBox} - The merged bounding box.\n   */\n  static sum(boxes) {\n    return boxes.reduce((psum, box) => psum.plus(box), new BoundingBox());\n  }\n}\n\nexport default BoundingBox;\n", "/**\n * @private\n * @type {function(number, number): string}\n */\nconst cellToString = (x, y) => `${x} ${y}`;\n\n/**\n * @private\n * @type {function(string): Cell}\n */\nconst stringToCell = (s) => s.split(' ').map((e) => parseInt(e, 10));\n\n/**\n * Map data structure that accepts Cells: [x: number, y: number] as keys.\n *\n * We need to implement this because\n * JS does not support non-primitive value types as keys (as of ES6)\n */\nclass CellMap {\n  /**\n   * @param {Array<CellEntry>} [entries=[]]\n   */\n  constructor(entries = []) {\n    /** @type {Map<string, *>} */ this.map = new Map();\n    entries.forEach(([x, y], value) => this.set([x, y], value));\n  }\n\n  /**\n   * Generate and return a `CellMap` from list of keys.\n   *\n   * @param {Array} keys - Array of cells, each of type `[number, number]`.\n   * @returns - The CellMap having the given keys with values mapped to null\n   */\n  static fromKeys(keys) {\n    const map = new CellMap();\n    keys.forEach(([x, y]) => map.set([x, y], null));\n    return map;\n  }\n\n  /**\n   * Generate and return a `CellMap` with the given entries.\n   *\n   * This is the same as the constructor, but is presented here\n   * as an analogue to `fromKeys`.\n   *\n   * @param {Array} entries - Array of [cell, value] pairs\n   * @returns The resulting CellMap having the given entries\n   */\n  static fromEntries(entries) {\n    return new CellMap(entries);\n  }\n\n  /**\n   * Return whether a cell is in the map to Map.\n   *\n   * @param {*} key - cell to search for, has type `[number, number]`.\n   * @returns A boolean indicating whether the cell is in the set\n   */\n  has(key) {\n    const [x, y] = key;\n    return this.map.has(cellToString(x, y));\n  }\n\n  /**\n   * Get the value for the given key.\n   * If not found, return `defaultValue` as a fallback.\n   *\n   * @param {Cell} key - The key to get values for.\n   * @param {*} defaultValue - The value to return when the key is not found.\n   * @returns - The found value or `defaultValue`\n   */\n  get(key, defaultValue) {\n    const [x, y] = key;\n    const value = this.map.get(cellToString(x, y));\n    return (value !== undefined) ? value : defaultValue;\n  }\n\n  /**\n   * Set the value for the given key.\n   *\n   * @param {Cell} key - The key to set values for.\n   * @param {*} value - The value to set.\n   */\n  set(key, value) {\n    const [x, y] = key;\n    this.map.set(cellToString(x, y), value);\n  }\n\n  /**\n   * Return the number of keys of the map, analogous to `Map`.\n   */\n  get size() {\n    return this.map.size;\n  }\n\n  /**\n   * Return the keys of this map as in `Map`.\n   * @returns A list of keys for the map.\n   */\n  keys() {\n    return [...this.map.keys()].map(stringToCell);\n  }\n\n  /**\n   * Return the entries (i.e. key, value pairs) of this map, as in `Map`.\n   * @returns A list of entries for the map.\n   */\n  entries() {\n    return [...this.map.entries()].map(([s, v]) => [stringToCell(s), v]);\n  }\n}\n\nexport default CellMap;\n", "import BoundingBox from '../../../BaseTypes/BoundingBox.js';\nimport CellMap from '../../../BaseTypes/CellMap.js';\n\n/**\n * Helper functions for oscillator-related functionality\n * @module\n */\n\n/**\n * @typedef {import('../../../Engine/Board/IBoard.js').IBoard} IBoard\n */\n\n/**\n * Given an oscillator, return the board of each phase of the oscillation. (t=0..p-1)\n * Given a non-oscillator, return `[]`.\n * @param {IBoard} board - The initial board.\n * @param {number} maxGens - Maximum number of gens to detect oscillation.\n * @returns {Array<IBoard>} - All phases of the oscillator, or an empty array.\n */\nexport const getPhases = (board, maxGens = 1000) => {\n  /**\n   * @param {Array} array\n   * @param {Set} set\n   * @returns {boolean}\n   */\n  const haveSameMembers = (array, set) => (\n    array.length === set.size && array.every((cell) => set.has(cell))\n  );\n\n  const appendNextBoard = ({ result, lastBoards, initialCellsSet }) => {\n    if (result.length !== 0) {\n      return { result, lastBoards, initialCellsSet };\n    }\n    /** @type {IBoard} */\n    const lastBoard = lastBoards[lastBoards.length - 1];\n    /** @type {IBoard} */\n    const currBoard = lastBoard.after();\n    if (haveSameMembers(currBoard.getCells(), initialCellsSet)) {\n      return {\n        result: lastBoards,\n        lastBoards: [],\n        initialCellsSet,\n      };\n    }\n    return {\n      result: [],\n      lastBoards: lastBoards.concat(currBoard),\n      initialCellsSet,\n    };\n  };\n\n  const repeatForMaxGens = new Array(maxGens).fill();\n  const initialData = {\n    result: [],\n    lastBoards: [board],\n    initialCellsSet: CellMap.fromKeys(board.getCells()),\n  };\n  const phases = repeatForMaxGens.reduce(appendNextBoard, initialData).result;\n  return phases; // Return empty array on failure\n};\n\n/**\n * Given the phases of an oscillator, calculate and return the subperiod of each cell.\n * @param {Array<IBoard>} oscPhaseBoards - The phases of an oscillator\n * @returns {Array<{cell: Cell, subperiod: number}>} - Subperiods for every cell.\n */\nexport const getSubperiodByCell = (oscPhaseBoards) => {\n  // Get the list of oscillator phases.\n  // Return a list of `{ cell, aliveGens }` where `aliveGens` is the gens `cell` was alive.\n  const getAliveGensByCell = (phases) => {\n    const phasesSet = phases.map(CellMap.fromKeys);\n    const allCells = CellMap.fromKeys([].concat(...phases)).keys();\n    const gens = phases.map((_, gen) => gen);\n    return allCells.map(\n      (cell) => ({\n        cell,\n        aliveGens: gens.filter((gen) => phasesSet[gen].has(cell)),\n      })\n    );\n  };\n\n  // Get the list of gens a cell was alive.\n  // Return the subperiod.\n  const getSubperiodOfOneCell = (aliveGens, period) => {\n    const aliveGensSet = new Set(aliveGens);\n    const subperiods = new Array(period)\n      .fill()\n      .map((_, i) => i + 1)\n      .filter((n) => period % n === 0);\n    const isSubperiodValid = (n) => aliveGens\n      .map((g) => (g + n) % period)\n      .every((g) => aliveGensSet.has(g));\n    const validSubperiods = subperiods.filter(isSubperiodValid);\n    return Math.min(...validSubperiods);\n  };\n\n  const period = oscPhaseBoards.length;\n  const result = getAliveGensByCell(oscPhaseBoards.map((b) => b.getCells()))\n    .map(\n      ({ cell, aliveGens }) => (\n        {\n          cell,\n          subperiod: getSubperiodOfOneCell(aliveGens, period),\n        }\n      )\n    );\n  return result;\n};\n\n/**\n * Given a board of the oscillator, return the stats of the oscillator.\n * @param {IBoard} board - Initial oscillator\n * @returns {*} stats - The oscillator statistics\n */\nexport const getOscStats = (board) => {\n  // Basic functions\n  /** @type {function(Array<number>): number} */\n  const getAverage = (l) => (l.reduce((a, b) => a + b, 0) / l.length);\n\n  /** @type {function(number): string} */\n  const formatFloat = (f) => f.toFixed(2);\n\n  /** @type {function(number): string} */\n  const formatPercentage = (f) => `${(100 * f).toFixed(2)}%`;\n\n  // Status functions\n  /** @typedef {Array<{cell: Cell, subperiod: number}>} Subperiods */\n\n  /** @type {function(Subperiods): number} */\n  const getRotorCount = (subperiods) => (\n    subperiods.filter(({ subperiod }) => subperiod !== 1).length\n  );\n\n  /** @type {function(Subperiods, number): number} */\n  const getStrictRotorCount = (subperiods, period) => (\n    subperiods.filter(({ subperiod }) => subperiod === period).length\n  );\n\n  /** @type {function(Subperiods): number} */\n  const getVolatility = (subperiods) => (\n    getRotorCount(subperiods) / subperiods.length\n  );\n\n  /** @type {function(Subperiods, number): number} */\n  const getStrictVolatility = (subperiods, period) => (\n    getStrictRotorCount(subperiods, period) / subperiods.length\n  );\n\n  // Main code\n  const phaseBoards = getPhases(board);\n  const period = phaseBoards.length;\n  if (period === 0) {\n    return {\n      success: false,\n      message: 'Failed to detect period of pattern',\n    };\n  }\n  const populations = phaseBoards.map((b) => b.getPop());\n  const subperiods = getSubperiodByCell(phaseBoards);\n\n  const result = {\n    success: true,\n    pattern: board.getCells(),\n    period,\n    phases: phaseBoards.map((p) => p.getCells()),\n    subperiods,\n    minPop: Math.min(...populations),\n    maxPop: Math.max(...populations),\n    avgPop: formatFloat(getAverage(populations)),\n    numCells: subperiods.length,\n    numRotorCells: getRotorCount(subperiods),\n    numStatorCells: subperiods.length - getRotorCount(subperiods),\n    numStrictRotorCells: getStrictRotorCount(subperiods, period),\n    volatility: formatPercentage(getVolatility(subperiods)),\n    strictVolatility: formatPercentage(getStrictVolatility(subperiods, period)),\n    boundingBox: BoundingBox.sum(phaseBoards.map((p) => p.getBox())),\n  };\n  return result;\n};\n", "import BoundingBox from '../../../BaseTypes/BoundingBox.js';\n\n/**\n * @typedef {import('../../../BaseTypes/Rule/Rule').Rule} Rule\n * @typedef {import('../IBoard').IBoard} IBoard\n * @typedef {import('./SimpleTotalisticBoard').default} SimpleTotalisticBoard\n */\n\n/**\n * @typedef {function(Array<Cell>): Array<Cell>} TransitionFunction\n */\n\n/**\n * This simple interface consists of a `pattern` and a `transitionFunction`.\n * It applies the `transitionFunction` on the `pattern` to get the next generation.\n * Other auxillary information is extracted from the `pattern`.\n *\n * IMPORTANT:\n *\n *  This class is made to reduce boilerplate.\n *  You don't need to inherit from this class;\n *  You just have to implement `I{Totalistic,INT}Board` interfaces.\n *\n *  If you are using this class, make sure to initialize `this.transitionFunction` properly,\n *  with the rule given as the parameter, with the proper type of {@link TransitionFunction}.\n *  For example classes, see {@link SimpleTotalisticBoard}.\n *\n * @implements {IBoard}\n *\n */\nclass AbcSimpleBoard {\n  /**\n   * @param {TwoStatePattern} pattern\n   * @param {Rule} rule\n   * @param {number} gen\n   */\n  constructor(pattern, rule, gen) {\n    /** @type {TwoStatePattern} */\n    this.pattern = pattern;\n    /** @type {Rule} */\n    this.rule = rule;\n    /** @type {number} */\n    this.gen = gen;\n    /**\n     * This should be overriden by concrete implementations!\n     * @type {any}\n     */\n    this.transitionFunction = undefined;\n  }\n\n  getCells() {\n    return this.pattern;\n  }\n\n  getCellsAndStates() {\n    return this.pattern.map((cell) => [cell, 1]);\n  }\n\n  getBox() {\n    return BoundingBox.sum(\n      this.pattern.map(([x, y]) => new BoundingBox(x, x, y, y))\n    );\n  }\n\n  getPop() {\n    return this.pattern.length;\n  }\n\n  /**\n   * Return a new board with the pattern iterated by the given amount.\n   *\n   * @param {number} [gens=1] - Number of generations to iterate\n   * @returns {AbcSimpleBoard} - The new board\n   */\n  after(gens = 1) {\n    const repeatForGens = new Array(gens).fill();\n    /** @type {TransitionFunction} */\n    const transFunc = this.transitionFunction;\n    /** @type {Array<Cell>} */\n    const iteratedPattern = repeatForGens.reduce(transFunc, this.pattern);\n    /** @type {any} */\n    const ThisClass = this.constructor;\n    return new ThisClass(iteratedPattern, this.rule, this.gen + gens);\n  }\n}\n\nexport default AbcSimpleBoard;\n", "import AbcSimpleBoard from './AbcSimpleBoard.js';\nimport CellMap from '../../../BaseTypes/CellMap.js';\n\nconst moore = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 0], [0, 1], [1, -1], [1, 0], [1, 1]];\n\n/**\n * @private\n * @param {Array<Cell>} cellsArray\n * @param {Array<Cell>} neighbors\n * @returns {CellMap}\n */\nconst getNeighborCounts = (cellsArray, neighbors) => {\n  const neighborCountsMap = new CellMap();\n  cellsArray.forEach(([x, y]) => {\n    neighbors.forEach(([dx, dy]) => {\n      const targetCell = [x + dx, y + dy];\n      const count = neighborCountsMap.get(targetCell) || 0;\n      neighborCountsMap.set(targetCell, count + 1);\n    });\n  });\n  return neighborCountsMap;\n};\n\n/**\n * @typedef {import('./AbcSimpleBoard').TransitionFunction} TransitionFunction\n */\n\n/**\n * @private\n * @param {TotalisticRule} totalisticRule\n * @returns {TransitionFunction}\n */\nconst makeTransFromTotalisticRule = (totalisticRule) => (cellsArray) => {\n  const { births, survivals } = totalisticRule;\n  const neighborCounts = getNeighborCounts(cellsArray, moore);\n  const cellsSet = CellMap.fromKeys(cellsArray);\n  const ruleCondition = ([cell, count]) => (\n    cellsSet.has(cell)\n      ? survivals.includes(count - 1) // -1: `count` includes `cell`, while B/S notation doesn't\n      : births.includes(count)\n  );\n  return (\n    [...neighborCounts.entries()]\n      .filter(ruleCondition)\n      .map(([cell/* count */]) => cell)\n  );\n};\n\n/**\n * A sample implementation for totalistic rules.\n * @class\n * @implements {ITotalisticBoard}\n */\nclass SimpleTotalisticBoard extends AbcSimpleBoard {\n  /**\n   * Initialize the board with the given pattern and rule.\n   *\n   * @constructor\n   * @param {TwoStatePattern} pattern - The initial pattern.\n   * @param {TotalisticRule} rule - The rule to operate on the pattern with.\n   * @param {number} [gen=0] - The initial generation.\n   */\n  constructor(pattern, rule, gen = 0) {\n    super(pattern, rule, gen);\n    this.transitionFunction = makeTransFromTotalisticRule(rule);\n  }\n}\n\nexport default SimpleTotalisticBoard;\n", "/** @module */\n\n/**\n * An enum for specifying neighbors for INT rules.\n */\nexport const INT = {\n  // eslint-disable-next-line quote-props\n  '0': '0',\n\n  '1c': '1c',\n  '1e': '1e',\n\n  '2c': '2c',\n  '2e': '2e',\n  '2a': '2a',\n  '2k': '2k',\n  '2i': '2i',\n  '2n': '2n',\n\n  '3c': '3c',\n  '3e': '3e',\n  '3a': '3a',\n  '3k': '3k',\n  '3i': '3i',\n  '3n': '3n',\n  '3j': '3j',\n  '3q': '3q',\n  '3r': '3r',\n  '3y': '3y',\n\n  '4c': '4c',\n  '4e': '4e',\n  '4a': '4a',\n  '4k': '4k',\n  '4i': '4i',\n  '4n': '4n',\n  '4j': '4j',\n  '4q': '4q',\n  '4r': '4r',\n  '4y': '4y',\n  '4t': '4t',\n  '4w': '4w',\n  '4z': '4z',\n\n  '5c': '5c',\n  '5e': '5e',\n  '5a': '5a',\n  '5k': '5k',\n  '5i': '5i',\n  '5n': '5n',\n  '5j': '5j',\n  '5q': '5q',\n  '5r': '5r',\n  '5y': '5y',\n\n  '6c': '6c',\n  '6e': '6e',\n  '6a': '6a',\n  '6k': '6k',\n  '6i': '6i',\n  '6n': '6n',\n\n  '7c': '7c',\n  '7e': '7e',\n\n  // eslint-disable-next-line quote-props\n  '8': '8',\n};\n\n/**\n * @typedef {keyof(INT)} INTNeighbor\n */\n\n// Initialize the index to neighbor table.\n/** @type {Array<INTNeighbor>} */\nexport const intNeighborsByIndex = (\n  `\n    0 1c 1e 2a 1c 2c 2a 3i 1e 2a 2e 3a 2k 3n 3j 4a\n    0 1c 1e 2a 1c 2c 2a 3i 1e 2a 2e 3a 2k 3n 3j 4a\n    1e 2k 2e 3j 2a 3n 3a 4a 2i 3r 3e 4r 3r 4i 4r 5i\n    1e 2k 2e 3j 2a 3n 3a 4a 2i 3r 3e 4r 3r 4i 4r 5i\n    1c 2c 2k 3n 2n 3c 3q 4n 2a 3i 3j 4a 3q 4n 4w 5a\n    1c 2c 2k 3n 2n 3c 3q 4n 2a 3i 3j 4a 3q 4n 4w 5a\n    2k 3y 3k 4k 3q 4y 4q 5j 3r 4t 4j 5n 4z 5r 5q 6a\n    2k 3y 3k 4k 3q 4y 4q 5j 3r 4t 4j 5n 4z 5r 5q 6a\n    1e 2k 2i 3r 2k 3y 3r 4t 2e 3j 3e 4r 3k 4k 4j 5n\n    1e 2k 2i 3r 2k 3y 3r 4t 2e 3j 3e 4r 3k 4k 4j 5n\n    2e 3k 3e 4j 3j 4k 4r 5n 3e 4j 4e 5c 4j 5y 5c 6c\n    2e 3k 3e 4j 3j 4k 4r 5n 3e 4j 4e 5c 4j 5y 5c 6c\n    2a 3n 3r 4i 3q 4y 4z 5r 3a 4a 4r 5i 4q 5j 5q 6a\n    2a 3n 3r 4i 3q 4y 4z 5r 3a 4a 4r 5i 4q 5j 5q 6a\n    3j 4k 4j 5y 4w 5k 5q 6k 4r 5n 5c 6c 5q 6k 6n 7c\n    3j 4k 4j 5y 4w 5k 5q 6k 4r 5n 5c 6c 5q 6k 6n 7c\n    1c 2n 2k 3q 2c 3c 3n 4n 2k 3q 3k 4q 3y 4y 4k 5j\n    1c 2n 2k 3q 2c 3c 3n 4n 2k 3q 3k 4q 3y 4y 4k 5j\n    2a 3q 3j 4w 3i 4n 4a 5a 3r 4z 4j 5q 4t 5r 5n 6a\n    2a 3q 3j 4w 3i 4n 4a 5a 3r 4z 4j 5q 4t 5r 5n 6a\n    2c 3c 3y 4y 3c 4c 4y 5e 3n 4n 4k 5j 4y 5e 5k 6e\n    2c 3c 3y 4y 3c 4c 4y 5e 3n 4n 4k 5j 4y 5e 5k 6e\n    3n 4y 4k 5k 4n 5e 5j 6e 4i 5r 5y 6k 5r 6i 6k 7e\n    3n 4y 4k 5k 4n 5e 5j 6e 4i 5r 5y 6k 5r 6i 6k 7e\n    2a 3q 3r 4z 3n 4y 4i 5r 3j 4w 4j 5q 4k 5k 5y 6k\n    2a 3q 3r 4z 3n 4y 4i 5r 3j 4w 4j 5q 4k 5k 5y 6k\n    3a 4q 4r 5q 4a 5j 5i 6a 4r 5q 5c 6n 5n 6k 6c 7c\n    3a 4q 4r 5q 4a 5j 5i 6a 4r 5q 5c 6n 5n 6k 6c 7c\n    3i 4n 4t 5r 4n 5e 5r 6i 4a 5a 5n 6a 5j 6e 6k 7e\n    3i 4n 4t 5r 4n 5e 5r 6i 4a 5a 5n 6a 5j 6e 6k 7e\n    4a 5j 5n 6k 5a 6e 6a 7e 5i 6a 6c 7c 6a 7e 7c 8\n    4a 5j 5n 6k 5a 6e 6a 7e 5i 6a 6c 7c 6a 7e 7c 8\n  `.trim().split(/\\s+/)\n);\n", "import AbcSimpleBoard from './AbcSimpleBoard.js';\nimport CellMap from '../../../BaseTypes/CellMap.js';\nimport { intNeighborsByIndex } from '../../../BaseTypes/Neighbors/INTNeighbors.js';\n\n/**\n * @typedef {import('./AbcSimpleBoard').TransitionFunction} TransitionFunction\n */\n\nconst weightsByRelPos = new Map([\n  [[-1, -1], 1],\n  [[-1, 0], 2],\n  [[-1, 1], 4],\n  [[0, -1], 8],\n  [[0, 0], 16],\n  [[0, 1], 32],\n  [[1, -1], 64],\n  [[1, 0], 128],\n  [[1, 1], 256],\n]);\n\n/**\n * @private\n * @param {Array<Cell>} cellsArray\n * @returns {CellMap}\n */\nconst getNeighborTransitionIndexes = (cellsArray) => {\n  const neighborTransitions = new CellMap();\n  cellsArray.forEach(([x, y]) => {\n    weightsByRelPos.forEach((w, [dx, dy]) => {\n      const targetCell = [x - dx, y - dy]; // So that [x, y] is at rel. pos. [dx, dy]\n      const currentWeight = neighborTransitions.get(targetCell) || 0;\n      neighborTransitions.set(targetCell, currentWeight + w);\n    });\n  });\n  return neighborTransitions;\n};\n\n/**\n * @private\n * @param {INTRule} rule\n * @returns {TransitionFunction}\n */\nconst makeTransitionFunction = (rule) => (cellsArray) => {\n  const transitionIndexesByCell = getNeighborTransitionIndexes(cellsArray);\n  const nextCells = [...transitionIndexesByCell.entries()]\n    .filter(([, tIndex]) => {\n      // The 0x10 bit is the center cell.\n      // eslint-disable-next-line no-bitwise\n      const cellIsAlive = (tIndex & 0x10) !== 0;\n      const validTransitions = cellIsAlive ? rule.survivals : rule.births;\n      return validTransitions.includes(intNeighborsByIndex[tIndex]);\n    })\n    .map(([cell] /* [cell, tIndex] */) => cell);\n  return nextCells;\n};\n\nclass SimpleINTBoard extends AbcSimpleBoard {\n  /**\n   * @param {TwoStatePattern} pattern\n   * @param {INTRule} rule\n   * @param {number} gen\n   */\n  constructor(pattern, rule, gen = 0) {\n    super(pattern, rule, gen);\n    /** @type {TransitionFunction} */\n    this.transitionFunction = makeTransitionFunction(rule);\n  }\n}\n\nexport default SimpleINTBoard;\n", "import SimpleTotalisticBoard from './Engine/Board/SimpleBoard/SimpleTotalisticBoard.js';\nimport TotalisticRule from './BaseTypes/Rule/TotalisticRule.js';\nimport INTRule from './BaseTypes/Rule/INTRule.js';\nimport SimpleINTBoard from './Engine/Board/SimpleBoard/SimpleINTBoard.js';\n\nconst life = new TotalisticRule([3], [2, 3]);\n\n/**\n * @typedef {import('./Engine/Board/IBoard.js').IBoard} IBoard\n * @typedef {import('./BaseTypes/Rule/Rule.js').Rule} Rule\n */\n\n/**\n * Create and return a new two-state board with the given pattern and rule.\n * @todo `rule` should be changed later to support different rulestings.\n *\n * @function makeBoard\n * @param {TwoStatePattern} pattern - The initial pattern.\n * @param {Rule} [rule=life] - The rule to use, this should be compatible with the board used.\n * @returns {IBoard} - The board\n */\nexport const makeBoard = (pattern, rule = life) => {\n  if (rule.constructor === TotalisticRule) {\n    return new SimpleTotalisticBoard(pattern, rule);\n  }\n  if (rule.constructor === INTRule) {\n    return new SimpleINTBoard(pattern, rule);\n  }\n  throw new Error('Invalid Rule!');\n};\n\n/**\n * Create and return a new empty board with the given rule.\n * @todo `rule` should be changed later to support different rulestings.\n *\n * @function makeBoard\n * @param {Rule} [rule] - The rule to use, this should be compatible with the board used.\n * @returns {IBoard} - The board\n */\nexport const makeEmptyBoard = (rule = life) => makeBoard([], rule);\n", "import { parse as parseRLE } from './RLEHelpers.js';\nimport { getOscStats } from './OscHelpers.js';\nimport * as AppConfig from '../../../AppConfig.js';\n\n/**\n * @typedef {import('../IController').IController}  IController\n * @typedef {import('../../Models/AppState').default} AppState\n */\n\n/**\n * A controller that updates the target with osc stats, with the given RLE.\n * @class\n * @implements {IController}\n */\nclass OscStatsController {\n  /**\n   * @param {AppState} targetState\n   * @param {HTMLInputElement} sourceElement\n   */\n  constructor(targetState, sourceElement) {\n    /** @type {AppState} */\n    this.targetState = targetState;\n    /** @type {HTMLInputElement} */\n    this.sourceElement = sourceElement;\n    /**\n     * The update callback.\n     * @type {function(Event): void}\n     */\n    this.update = (event) => {\n      if (!event.target) {\n        this.targetState.setValue(\n          {\n            success: false,\n            message: 'No event.target',\n          }\n        );\n        return;\n      }\n      const rleString = this.sourceElement.value;\n      const { pattern, rule } = parseRLE(rleString);\n      if (!rule) {\n        this.targetState.setValue(\n          {\n            success: false,\n            message: 'Unable to parse rule',\n          }\n        );\n        return;\n      }\n      const initialBoard = AppConfig.makeBoard(pattern, rule);\n      this.targetState.setValue(getOscStats(initialBoard));\n    };\n  }\n}\n\nexport default OscStatsController;\n", "/**\n * @typedef {import('../../../BaseTypes/BoundingBox').default} BoundingBox\n */\n\nconst colorscheme = {\n  background: '#eeeeee',\n  stator: '#000000',\n  strictRotor: '#999999',\n  liveCell: '#000000',\n};\n\n// Cell size follows `box-sizing: border-box`\n// In other words, borders on all four sides are counted as cellSize.\nconst cellSizes = {\n  cell: 10,\n  border: 1,\n  liveCell: 4,\n  liveBorder: 2,\n};\n\n/** @type {function(number, number): string} */\nconst makeGradientColor = (numColors, i) => {\n  const hue = Math.floor(360 * (i / numColors));\n  return `hsl(${hue}, 100%, 70%)`;\n};\n\n/** @type {function(number, Array<number>): Map<number, string>} */\nexport const makeColorMap = (period, subperiods) => {\n  // Remove special subperiods:\n  //  subperiod 1 (stator)\n  //  subperiod `period` (full-period rotor)\n  const subperiodsSet = new Set(subperiods);\n  subperiodsSet.delete(1);\n  subperiodsSet.delete(period);\n  const nonSpecialSubperiods = [...subperiodsSet.values()].sort((a, b) => a - b);\n  /** @type {Array<[number, string]>} */\n  const nonSpecialSubperiodsAndColors = nonSpecialSubperiods.map(\n    (sp, i) => [sp, makeGradientColor(nonSpecialSubperiods.length, i)]\n  );\n  return new Map([\n    ...nonSpecialSubperiodsAndColors,\n    [1, colorscheme.stator],\n    [period, colorscheme.strictRotor],\n  ]);\n};\n\n// Draw the initial grid\n/**\n * @param {HTMLCanvasElement} canvas\n * @param {*} context\n * @param {BoundingBox} boundingBox\n */\nexport const drawGrid = (canvas, context, boundingBox) => {\n  // We have to manipulate the canvas, so first beg pardon to ESLint\n  /* eslint-disable no-param-reassign */\n\n  const { cell: cellSize, border: borderWidth } = cellSizes;\n\n  // First fill rect with empty cell backgrounds.\n  const patternWidth = boundingBox.xmax - boundingBox.xmin + 1;\n  const patternHeight = boundingBox.ymax - boundingBox.ymin + 1;\n\n  // Add one cell for padding on each side.\n  canvas.width = cellSize * (patternWidth + 2);\n  canvas.height = cellSize * (patternHeight + 2);\n\n  // Draw background\n  context.fillStyle = colorscheme.background;\n  context.fillRect(0, 0, canvas.width, canvas.height);\n\n  // Draw cell borders\n  context.fillStyle = 'white';\n  new Array(patternHeight + 2).fill().forEach((_, i) => {\n    context.fillRect(0, cellSize * i, canvas.width, borderWidth);\n    context.fillRect(0, cellSize * (i + 1) - borderWidth, canvas.width, borderWidth);\n  });\n  new Array(patternWidth + 2).fill().forEach((_, i) => {\n    context.fillRect(cellSize * i, 0, canvas.height, borderWidth);\n    context.fillRect(cellSize * (i + 1) - borderWidth, 0, borderWidth, canvas.height);\n  });\n};\n\n/**\n * Draw the cell at `(x, y)` with the given color.\n * @param {*} context\n * @param {number} x\n * @param {number} y\n * @param {string} color\n */\nexport const drawCell = (context, x, y, color) => {\n  context.fillStyle = color;\n  // Displace cell by (+1, +1) to compensate for the 1-cell borders above.\n  const cellSize = cellSizes.cell;\n  const borderWidth = cellSizes.border;\n  const rect = [\n    (x + 1) * cellSize + borderWidth,\n    (y + 1) * cellSize + borderWidth,\n    cellSize - 2 * borderWidth,\n    cellSize - 2 * borderWidth,\n  ];\n  context.fillRect(...rect);\n};\n\n/**\n * Draw the interior of the cell at (x, y), with styling as live cell.\n * @param {*} context\n * @param {number} x\n * @param {number} y\n */\nexport const drawLiveCellInterior = (context, x, y) => {\n  context.fillStyle = colorscheme.liveCell;\n  const { cell: cellSize, liveCell: liveCellSize } = cellSizes;\n  const rect = [\n    // Draw at (x + 1, y + 1) for the same reason.\n    // Padding at each side is half the difference of cell sizes.\n    (x + 1) * cellSize + 0.5 * (cellSize - liveCellSize),\n    (y + 1) * cellSize + 0.5 * (cellSize - liveCellSize),\n    liveCellSize,\n    liveCellSize,\n  ];\n  context.fillRect(...rect);\n};\n\n/**\n * Draw the border of the cell at (x, y), with styling as a live cell.\n * @param {*} context\n * @param {number} x\n * @param {number} y\n */\nexport const drawLiveCellBorder = (context, x, y) => {\n  context.fillStyle = colorscheme.liveCell;\n  const {\n    cell: cellSize,\n    border: borderWidth,\n    liveBorder: liveBorderWidth,\n  } = cellSizes;\n  // Draw at (x + 1, y + 1) for the same reason.\n  const xLeft = (x + 1) * cellSize + borderWidth;\n  const xRight = (x + 2) * cellSize - borderWidth - liveBorderWidth;\n  const yTop = (y + 1) * cellSize + borderWidth;\n  const yBottom = (y + 2) * cellSize - borderWidth - liveBorderWidth;\n  const liveBorderLength = cellSize - 2 * borderWidth;\n  context.fillRect(xLeft, yTop, liveBorderLength, liveBorderWidth);\n  context.fillRect(xLeft, yBottom, liveBorderLength, liveBorderWidth);\n  context.fillRect(xLeft, yTop, liveBorderWidth, liveBorderLength);\n  context.fillRect(xRight, yTop, liveBorderWidth, liveBorderLength);\n};\n", "import * as CanvasHelpers from './CanvasHelpers.js';\n\n/**\n * @typedef {import('../../Models/AppState').default} AppState\n */\n\nconst drawLiveCellOptions = new Map(\n  [\n    ['none', () => {}],\n    ['border', CanvasHelpers.drawLiveCellBorder],\n    ['interior', CanvasHelpers.drawLiveCellInterior],\n  ]\n);\n\n/** @type {function(Array<{cell: Cell, subperiod: number}>): Array<number>} */\nconst getArrayFromSubperiods = (subperiods) => {\n  const subperiodSet = new Set(subperiods.map((e) => e.subperiod));\n  const subperiodArray = [...subperiodSet.values()].sort((a, b) => a - b);\n  return subperiodArray;\n};\n\n/**\n * The view that takes care of the oscillizer canvas.\n * @class\n * @implements {IView}\n */\nclass OscillizerCanvasView {\n  /**\n   * @param {*} oscData\n   * @param {AppState} cellStyle\n   * @param {HTMLCanvasElement} targetCanvas\n   */\n  constructor(oscData, cellStyle, targetCanvas) {\n    this.oscData = oscData;\n    this.cellStyle = cellStyle;\n    this.targetCanvas = targetCanvas;\n    /**\n     * The `update` callback that updates the view.\n     * @type {function(Event): void}\n     */\n    this.update = (/* event */) => {\n      const context = this.targetCanvas.getContext('2d');\n      if (!context) {\n        return;\n      }\n\n      // Dependent data\n      const {\n        success,\n        pattern,\n        period,\n        subperiods,\n        boundingBox,\n      } = this.oscData.value;\n      const colorMap = CanvasHelpers.makeColorMap(period, getArrayFromSubperiods(subperiods));\n\n      // Helper functions\n      const drawSubperiod = ({ cell: [x, y], subperiod }) => {\n        CanvasHelpers.drawCell(\n          context,\n          x - boundingBox.xmin,\n          y - boundingBox.ymin,\n          colorMap.get(subperiod)\n        );\n      };\n\n      const drawLiveCell = ([x, y]) => {\n        const drawLiveCellOption = drawLiveCellOptions.get(this.cellStyle.value || 'none');\n        drawLiveCellOption(context, x - boundingBox.xmin, y - boundingBox.ymin);\n      };\n\n      // Main Logic\n      context.clearRect(0, 0, targetCanvas.width, targetCanvas.height);\n      if (!success) {\n        return;\n      }\n      CanvasHelpers.drawGrid(targetCanvas, context, boundingBox);\n      subperiods.forEach(drawSubperiod);\n      pattern.forEach(drawLiveCell);\n    }; // end of `this.update`\n  }\n}\n\nexport default OscillizerCanvasView;\n", "/** @typedef {import('../../Models/AppState').default} AppState */\n\n/**\n * @class\n * @implements {IView}\n */\nclass OscStatsView {\n  /**\n   * @param {AppState} sourceState\n   * @param {HTMLElement} targetElement\n   */\n  constructor(sourceState, targetElement) {\n    this.sourceState = sourceState;\n    this.targetElement = targetElement;\n    /** @type {function(Event): void} */\n    this.update = (/* event */) => {\n      const data = this.sourceState.value;\n      if (!data.success) {\n        this.targetElement.innerText = `Failure: ${data.message}`;\n      } else {\n        this.targetElement.innerHTML = `\n          <table>\n            <thead>\n              <tr>\n                <th>Property</th>\n                <th>Value</th>\n              </tr>\n            </thead>\n            <tbody>\n              <tr class=\"stripe-dark\">\n                <td>Period</td>\n                <td>${data.period}</td>\n              </tr>\n              <tr class=\"stripe-dark\">\n                <td>Population</td>\n                <td>Avg: ${data.avgPop}<br>Min: ${data.minPop}<br>Max: ${data.maxPop}</td>\n              </tr>\n              <tr class=\"stripe-dark\">\n                <td>Cells</td>\n                <td>\n                  Rotor: ${data.numRotorCells}<br>\n                  Stator: ${data.numStatorCells}<br>\n                  Total: ${data.numRotorCells + data.numStatorCells}\n                </td>\n              </tr>\n              <tr class=\"stripe-dark\">\n                <td>Volatility</td>\n                <td>${data.volatility}<br>(Strict: ${data.strictVolatility})</td>\n              </tr>\n              <tr class=\"stripe-dark\">\n                <td>Bounding Box</td>\n                <td>\n                  ${data.boundingBox.xmax - data.boundingBox.xmin + 1}\n                  x ${data.boundingBox.ymax - data.boundingBox.ymin + 1}\n                </td>\n              </tr>\n            </tbody>\n          </table>\n        `;\n      } // if ... else\n    }; // this.update\n  }\n}\n\nexport default OscStatsView;\n", "import AppState from './MVC/Models/AppState.js';\nimport EventTargetPassingController from './MVC/Controllers/PassingController/EventTargetPassingController.js';\nimport OscStatsController from './MVC/Controllers/OscStatsController/OscStatsController.js';\nimport OscillizerCanvasView from './MVC/Views/OscillizerCanvasView/OscillizerCanvasView.js';\nimport OscStatsView from './MVC/Views/OscStatsView/OscStatsView.js';\n\nconst appState = {\n  oscInfo: new AppState(),\n\n  /*\n    Cell style for cells at gen 0\n    this.value: cellStyles.property\n  */\n  initialCellStyle: new AppState(),\n};\n\n// @ts-ignore\nif (window.Cypress) {\n  // @ts-ignore\n  window.appState = appState;\n}\n\n/* Action -> State update code */\n\nconst inputRleSubmitter = document.getElementById('input-rle-submitter');\nconst cellStyleSelector = document.getElementById('cell-style-selector');\nconst inputRleContainer = document.getElementById('input-rle-container');\n\nconst oscController = new OscStatsController(appState.oscInfo, inputRleContainer);\nconst cellStyleController = new EventTargetPassingController(appState.initialCellStyle);\n\ninputRleSubmitter.addEventListener('click', oscController.update);\ncellStyleSelector.addEventListener('change', cellStyleController.update);\n\n/* State -> UI update code */\n\nconst oscCanvas = /** @type {HTMLCanvasElement} */ (document.getElementById('output-osc-canvas'));\nconst oscCanvasView = new OscillizerCanvasView(\n  appState.oscInfo, appState.initialCellStyle, oscCanvas\n);\nappState.oscInfo.eventTarget.addEventListener('change', oscCanvasView.update);\n\nconst oscStatsElement = document.getElementById('output-osc-data');\nconst oscStatsView = new OscStatsView(appState.oscInfo, oscStatsElement);\nappState.oscInfo.eventTarget.addEventListener('change', oscStatsView.update);\n"],
  "mappings": "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",
  "names": []
}
